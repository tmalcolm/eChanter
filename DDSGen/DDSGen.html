<html>
<head><title>DDSGen - DDS wavetable generation for 8bit uCs</title>


<style>

.tabStrip ul {
	margin: 0;
	padding: 0;
	list-style-type: none;
}
.tabStrip li {
	margin: 0 2px 0 0;
	list-style-type: none;
	float: left;
}
.tabLink {
	display: block;
	text-decoration: none;
	padding: 5px;
	background: #e8e8e8;
	border: #dadada solid;
	border-width: 1px 1px 0 1px;
	color: #8a8a8a;
}
.tabLinkActive {
	display: block;
	text-decoration: none;
	padding: 5px;
	background: #e0e0e0;
	border: #c0c0c0 solid;
	border-width: 1px 1px 0 1px;
	color: #0066ff;
}
.tabContent {
	display: none;
}
.tabContentActive {
	display: block;
	clear: both;
	background: #f0f0f0;
	border: 1px #dedede solid;
	padding: 10px;
}
</style>

<script>

var DEBUG = false;

var dataTxt = "";
var dataObj = {};
var sampleRate;
var numSamples;
var partials = [];
var currentSample = [];
var minSampleVal = 0;
var maxSampleVal = 0;




// converts dB to Amplitude for an array of partials
// with corresponding levels
// expects data as an array of 2 element arrays
//   [[P, L], ... [Pn, Ln]]
// conversion will also normailze dB levels and
// apply a dB level boost before conversion

function convertDecibelsToAmplitude(partials, normalize, normVal) {

  // Multiple iterations over the partial data is not very efficient
  // but the iterations make for readable, are obvious code
  // and data sets are small so there's no real performance issue.

  var i = 0;
  var db = 0;
  var isDB = false;

  var min = max = partials[0][1];

  for (i = 0; i < partials.length; i++) {
    if (partials[i][1] < 0) {
      isDB = true;
      break;
    }

  }

  // do actual conversion from dB to Amplitude
  if (isDB) {
    for (i = 0; i < partials.length; i++) {
      if (partials[i][1] < min) min = partials[i][1];
      else if (partials[i][1] > max) max = partials[i][1];
    }


    for (i = 0; i < partials.length; i++) {
      db = partials[i][1];
      if (normalize) {
        db -= max * (normVal/100);
      }

      // do actual conversion from dB to Amplitude
      // forula is 10^(db/20)
      partials[i][1] = Math.pow(10, (db/20));

    }

  }


}



function scaleSample(dataObj) {


  var delta = 0;
  var mult = 1;
  var a = 1.0;
  var s = currentSample;

  // ensure delta val is large enough to make all data points positive
  if (minSampleVal < 0 ) {
    delta = minSampleVal * -1;
  }
  minSampleVal += delta;
  maxSampleVal += delta;

  // scaling factor to make ensure 0 >= val <= 255
  mult = 255 / maxSampleVal;

  if (DEBUG) alert ("min:"+ minSampleVal + " max:" + maxSampleVal + " mult:"+ mult);

  for (var i = 0; i< s.length; i++) {
    // make positive, scale from 0-255, reduce by amplitude adjustment
    s[i] = ((s[i] + delta) * mult) * a;
    s[i] = s[i].toFixed(0); // make whole number

    // assign rounded min/max vals
    if (s[i] > maxSampleVal) maxSampleVal = s[i];
    else if (s[i] < minSampleVal) minSampleVal = s[i];

  }



}


function outputSample(dataObj) {


  var outputTxtArea = document.getElementById("samples");
  outputTxtArea.value = "";

  outputTxtArea.value +=    "sample_len = "+ currentSample.length +";"
	                        + "\n"
	                        + "sample["+ currentSample.length +"] = { \n"
	                        + currentSample
	                        + "\n"
	                        + "};"
	                        + "\n\n";

}


function plotSample() {

// TJM FIXME - make robust - this is just a quick hack for development!!
    var f1 = 127; // centers plot
    var f2 = 0.5; // multiplies Y. By trial-and-error, 0.5 appears to produce a decent result

    var plot = document.getElementById("wavePlot");
    var ctx = plot.getContext('2d');

    ctx.clearRect(0,0,356,356);
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(0, f1-currentSample[0]*f2);
    for(var i=1; i< currentSample.length; i++){
      ctx.lineTo(i, f1-currentSample[i]*f2);
    }

    ctx.stroke();
    ctx.closePath();

}


function generate() {

  var elem;
  var elemArray;
  var bool = false;

//	<p><b>For DDS, Freq of 31.25Hz @ 8kHz sample rate generates 256 samples.</b></p>

  elem = document.getElementById("sampleRate");
  sampleRate = elem.options[elem.selectedIndex].value;
  sampleRate = parseInt(sampleRate*1000);


  elem = document.getElementById("numSamples");
  numSamples = elem.options[elem.selectedIndex].value;
  numSamples = parseInt(numSamples);


  elem = document.getElementById("partials");
  elemArray = elem.getElementsByTagName("input");
  for (var i=0; i < elemArray.length; i++) {
    if (isNaN(elemArray[i].value)) {
      partials[i] = 0.0;
    } else {
      partials[i] = elemArray[i].value * 1.0;
      bool = true;
    }

  }

  if (!bool) partials[0] = 1.0;

  if (DEBUG) alert("Sample Rate :" + sampleRate +" Num Samples: " + numSamples + "\n" + " Partials: " + partials);

//  dataTxt = document.getElementById("importExport").value;
//  dataObj = JSON.parse(dataTxt);

  createSample();
  scaleSample();
  outputSample();
  plotSample();

//  openTab(2);


}


function createSample() {

  var increment = 0.0;
  var i, j, p, a = 0;
  var freq = 0.0;

  currentSample = new Array(numSamples);
  minSampleVal = maxSampleVal = 0;



  // NOTE : Freq of 31.25Hz @ 8kHz sample rate generates 256 samples.
  //      : Freq of 62.50Hz @ 16kHz sample rate generates 256 samples.
  //      : etc.


  // Sinewave generation derived from pseudocode at
  //     http://www.topherlee.com/software/pcm-tut-sine.html
  //
  freq = sampleRate/numSamples;

  increment = 2 * Math.PI * (freq/sampleRate);

  for(i = 0; i < numSamples; i++) {
    currentSample[i] = 0.0;

    // accumulate sample values with calculated partials
    for (j = 0; j < partials.length; j++) {

        p = j+1;
        a = partials[j];
        if (a > 0)
          currentSample[i] += Math.sin(p*increment*i) * a;

    }

    // track max and min vals
    if (currentSample[i] > maxSampleVal) maxSampleVal = currentSample[i];
    else if (currentSample[i] < minSampleVal) minSampleVal = currentSample[i];

  }

alert ("min:"+ minSampleVal + " max:" + maxSampleVal);

  if (DEBUG) alert (currentSample);


}



</script>

<script type="text/javascript" language="javascript">
  //http://kyleschaeffer.com/tutorials/create-a-dhtml-tab-strip/
var activeTab = 1;
function openTab(tabId) {
  // reset old tab and content
  document.getElementById("tabLink"+activeTab).className = "tabLink";
  document.getElementById("tabContent"+activeTab).className = "tabContent";
  // set new tab and content
  document.getElementById("tabLink"+tabId).className = "tabLinkActive";
  document.getElementById("tabContent"+tabId).className = "tabContentActive";
  activeTab = tabId;
}
</script>

<body onLoad="openTab(1);">

<h2>DDSGen</h2>
<h3>DDS wavetable sample generation, with partials, for 8bit Microcontrollers</h3>

<div id="sampleConfigPane">

	<table border="0">
	<tr>
	<td>Number of Samples:</td>
	<td>
		<select id="numSamples">
			<option value="16">16</option>
			<option value="32">32</option>
			<option value="64">64</option>
			<option value="128">128</option>
			<option value="256" selected="selected">256</option>
			<option value="512">512</option>
			<option value="1024">1024</option>
			<option value="2048">2148</option>
			<option value="4096">4096</option>
		</select>
	</td>
	<td>Sample Rate (kHz):</td>
	<td>
		<select id="sampleRate">
			<option value="">4</option>
			<option value="8"  selected="selected">8</option>
			<option value="16">16</option>
			<option value="22">22</option>
			<option value="32">32</option>
			<option value="44.1">44.1</option>
		</select>
	</td>
	</tr>
	</table>

	<input type="button" value="Generate now!" onClick="generate(); return false;" >

</div>

<div class="tabStrip">
	<ul>
		<li><a href="javascript:openTab(1);" class="tabLinkActive" id="tabLink1">Data</a></li>
		<li><a href="javascript:openTab(2);" class="tabLink" id="tabLink2">Import-Export</a></li>
		<li><a href="javascript:openTab(3);" class="tabLink" id="tabLink3">Converters</a></li>
		<li><a href="javascript:openTab(4);" class="tabLink" id="tabLink4">Help</a></li>
	</ul>
</div>

<div  class="tabContent" id="tabContent1">

	<br>
	<p>Spectrum data <br>
	<table border="0">
	<tr>
		<td>1</td>
		<td>2</td>
		<td>3</td>
		<td>4</td>
		<td>5</td>
		<td>6</td>
		<td>7</td>
		<td>8</td>
		<td>9</td>
		<td>10</td>
		<td>11</td>
		<td>12</td>
		<td>13</td>
		<td>14</td>
		<td>15</td>
	</tr>
	<tr id="partials">
		<td><input id="p1" type="text" size="4"></td>
		<td><input id="p2" type="text" size="4"></td>
		<td><input id="p3" type="text" size="4"></td>
		<td><input id="p4" type="text" size="4"></td>
		<td><input id="p5" type="text" size="4"></td>
		<td><input id="p6" type="text" size="4"></td>
		<td><input id="p7" type="text" size="4"></td>
		<td><input id="p8" type="text" size="4"></td>
		<td><input id="p9" type="text" size="4"></td>
		<td><input id="p10" type="text" size="4"></td>
		<td><input id="p11" type="text" size="4"></td>
		<td><input id="p12" type="text" size="4"></td>
		<td><input id="p13" type="text" size="4"></td>
		<td><input id="p14" type="text" size="4"></td>
		<td><input id="p15" type="text" size="4"></td>
	</tr>
	</table>



    <textarea id="samples" style="width:400px; height:200px; overflow:auto; border:solid 1px #cccccc;">
[
  { "id"        : "clarinet_fundemental",
    "frequency" : 31.25,
    "amplitude" : 1.0,
    "partials"  : [
                     [1.0, 0.8],
                     [3.0, 0.75],
                     [5.0, 0.5],
                     [7.0, 0.14],
                     [9.0, 0.5],
                     [11.0, 0.12],
                     [13.0, 0.17]
                  ]
  }
]
     </textarea>

     <span style="width:50px;"></span>

     <canvas id="wavePlot" style="height:256px; width:256px; border:1px solid black;"></canvas>



  </div>


  <div  class="tabContent" id="tabContent2">
    <p>Sample config data  <br>
    Copy/paste from text file
    </p>
    <textarea id="importExport" style="width:450px; height:400px; overflow:auto; border:solid 1px #cccccc;">
    </textarea>
  </div>


  <div  class="tabContent" id="tabContent3">
    <h2>Convert dB to Amplitude</h2>
    <script>
    function inlineDBConvert() {
      var d = document.getElementById("dbVal").value;
      document.getElementById("ampVal").value = Math.pow(10, (d/20)).toFixed(5);
    }
    </script>
    dB <input type="text" id="dbVal"> <input type="button" value="->" onClick="inlineDBConvert();return false;"> <input type="text" id="ampVal">
    <p>&nbsp;</p>
  </div>


  <div  class="tabContent" id="tabContent4">
    <!-- clarinet partials from http://www.phy.mtu.edu/~suits/clarinet.html -->
    <h2>Data Format</h2>

    <p style="width:600px;">
    Input data is written as JSON objects. In plain English, data input is structured
    so that a Web page parsing script can read it easily.<br>
    The parsing script expects to 'see' an array of objects, where each object
    contains the data representing a note. <br>

    <h2>Sample Config Fields</h2>
    <p style="width:600px;">
    <b>Sample Rate</b> is the output sample rate. 8000Hz is typical for Arduino audio applications.<br>
    <b>Amplitude scaling</b> is a multiplaction factor that is applied to the calculated sample value.
    The Sine function calculates values between 1 and -1, so some multiplaction factor is needed to
    generate samples suitable for PWM usage. <br>
    <b>DC Offset</b> is a constant value that is added to each sample. <br>
    <b>Normalize</b> when checked, dB values for partial data will be noralized to 0.
    <b>by %</b> controls the amount of normalization applied. For example, if dB values should be normalized
    by 10dB, and by % is 50, values will be increased by 50% of 10dB, ie. by 5dB.
    </p>

    <h2>Data Fields</h2>
    <p style="width:600px;">
    <b>The fields 'id' and 'frequency' are required.</b> Both fields should be unique for any given data set.<br>
    If <b>amplitude</b> is <i>not</i> included, a default value of 1.0 is used. <br>
    If <b>partials</b> are <i>not</i> included, a pure sign wave will be generated using the default value of [[1.0,1.0]].<br>
    If <b>partials</b> is the ID of another note, that note's partials will be used. <br>
    </p>

    <p>
    Partials data is an array of 2 element arrays, where element 1 is a partial interval,
    and element 2 is a dB level or amplitude value. For example, take this array with 3 data pairs:
    <pre><code>
    [
      [1, 0.80],
      [2, 0.6],
      [4, 0.4]
    ]
    </code></pre>
    'Translating' this into words would be some thing like:
    <pre><code>
    Generate a sample using proportions
    of these 3 harmonic elements:
      The note frequency at 80% amplitude,
      the 2nd harmonic at 60% amplitude,
      and the 4th harmonic at 40% amplitude.
    </code></pre>

    </p>

    <h2>Example</h2>
    <p style="width:600px;">
    Here's an example for generating clarinet samples at an 8000Hz sample rate.
    In the example, the note at 235Hz is defined with 7 harmonic partials, and no amplitude adjustment. Samples for
    the second note, at 470Hz, use the same partials as the first note, but adjust the amplitudes to
    make the sample data 'quieter.'
    <pre><code>
    [
	  { "id"        : "clarinet_fundemental",
	    "frequency" : 235.0,
	    "amplitude" : 1.0,
	    "partials"  : [
	                     [1.0, 1.0],
	                     [3.0, 0.75],
	                     [5.0, 0.5],
	                     [7.0, 0.14],
	                     [9.0, 0.5],
	                     [11.0, 0.12],
	                     [13.0, 0.17]
	                  ]
	  },

	  { "id"        : "clarinet_note_2",
	    "frequency" : 470.0,
	    "amplitude" : 0.92,
	    "partials"  : "clarinet_fundemental"
	  }
	]
    </code></pre>
    Partial data was taken from <a href="http://www.phy.mtu.edu/~suits/clarinet.html">here</a>.

  </div>


</body>
</html>

<!--
	int sampleRate = 0;
	int freq = 0;
	int amplitude = 0;
	int dcOffset = 0;
	String another = "";

	// Sinewave creation algorythm comes from:
	// http://embeddedsystemdesign.blogspot.com/2007/12/digital-dual-tone-generation-using.html
	//
	public void generateInstrument() {

        double increment = 0;
        int nSamples = 0;
		int i, n, s = 0;

		nSamples = sampleRate/freq;
		increment = 2.0 * Math.PI * ((float)freq/(float)sampleRate);

		System.out.print("f"+freq+"_sr"+sampleRate+"_len = "+nSamples+";");
		System.out.print("f"+freq+"_sr"+sampleRate+" ["+nSamples+"] = { ");

        for(i = 0; i < nSamples; i++) {

            s = dcOffset + (int)(amplitude * (

			Math.sin(increment*i)
			+ Math.sin(3*increment*i) *0.75
			+ Math.sin(5*increment*i) *0.5
			+ Math.sin(7*increment*i) *0.14
			+ Math.sin(9*increment*i) * 0.5
			+ Math.sin(11*increment*i) * 0.12
			+ Math.sin(13*increment*i) * 0.17
            )
            );

			System.out.print(s);

			if (i == nSamples -1) {
				System.out.println(" };");
			} else if (i % 20 == 0) {
				System.out.println(",");
			} else {
				System.out.print(", ");
			}

		}

	}





	// Sinewave creation algorythm comes from:
	// http://embeddedsystemdesign.blogspot.com/2007/12/digital-dual-tone-generation-using.html
	//
	public void generateSine() {

		double wT, y0, y1, y2 = 0;
		int nSamples = 0;
		int y = 0;

		nSamples = sampleRate/freq;
		wT = 2.0 * Math.PI * ((float)freq/(float)sampleRate);

		y0 = 0; /*initial value*/
		y1 = Math.sin (wT); /*initial value: sin (wT)*/

		System.out.print("f"+freq+"_sr"+sampleRate+"_len = "+nSamples+";");
		System.out.print("f"+freq+"_sr"+sampleRate+" ["+nSamples+"] = { ");

		for (int i=0; i<nSamples; i++) {

			y2 = (2*y1*Math.cos (wT)-y0); /*compute y2*/
			y = (int)(y2*amplitude)+50; /*amplitude scaling and dc shift*/
			y0 = y1; /*assign present values to previous value*/
			y1 = y2;
			System.out.print(y);
			if (i == nSamples -1) {
				System.out.println(" };");
			} else if (i % 20 == 0) {
				System.out.println(",");
			} else {
				System.out.print(", ");
			}

		}

	}

-->



<!--

function V1_parseInputData() {

  var increment = 0.0;
  var nSamples = 0;
  var n, i, j, p, a = 0;
  var s = [];


  var outputTxtArea = document.getElementById("results");
  outputTxtArea.value = "";
  var dataTxt = document.getElementById("editor").value;
  var dataObj = JSON.parse(dataTxt);

  var id = "";
  var freq = 0.0;
  var amplitude = 0.0;
  var partials;
  var sampleRate = document.getElementById("sampleRate").value;
  sampleRate = parseInt(sampleRate);
  var ampScalingFactor = document.getElementById("ampScalingFactor").value;
  ampScalingFactor = parseInt(ampScalingFactor);
  var dcOffset = document.getElementById("dcOffset").value;
  dcOffset = parseInt(dcOffset);
  var normVal = document.getElementById("normVal").value;
  if (isNaN(normVal)) normVal = 100;
  else normVal = parseInt(normVal);

  var normalize = document.getElementById("normalize").checked;


  if (DEBUG) alert (JSON.stringify(dataObj));
  if (DEBUG) alert ("sample rate: " + sampleRate +"\namp scaling: " + ampScalingFactor +"\ndc offset: " +dcOffset);


  // Sinewave generation derived from pseudocode at
  //     http://www.topherlee.com/software/pcm-tut-sine.html
  //
  for (n=0; n < dataObj.length; n++) {

    s = [];

    id = dataObj[n]["id"];
    freq = dataObj[n]["frequency"]; // frequency of note
    if (dataObj[n]["amplitude"])
      amplitude = dataObj[n]["amplitude"]; // amplitude adjust for note (higher notes typically quieter)
    else
      amplitude = 1.0;
    if (dataObj[n]["partials"])
      partials = dataObj[n]["partials"]; // list of partials and amplitudes for note
    else
      partials = [ [1.0, 1.0] ];

    convertDecibelsToAmplitude(partials, normalize, normVal);

    nSamples = parseInt(sampleRate/freq);
	increment = 2 * Math.PI * (freq/sampleRate);

    if (typeof partials == "string") {
      if (DEBUG) alert ("Copying partials for \'" + dataObj[n]["id"] + "\' from \'" + partials +"\'");
      partials = getPartialsById(partials);
    }

    for(i = 0; i < nSamples; i++) {

      // accumulate sample values with calculated partials
      // make positive 2.0 >= s <= 0.0
      // multiply by amplitude factor (default = 127)

      s[i] = 0.0;

      for (j = 0; j < partials.length; j++) {

        p = partials[j][0];
        a = partials[j][1];

        s[i] += Math.sin(p*increment*i) * a;


      }
      // adjust sample for amplitude scaling and dc offset
      s[i] = dcOffset + (ampScalingFactor * s[i])


      // scale by frequency sample specific ampl;itude correction
      // AND make a whole number for uC PWM output

      s[i] = parseInt(amplitude * s[i]);

	}

    if (DEBUG) alert (s);

	outputTxtArea.value +=    "f"+id+"_sr"+sampleRate+"_len = "+nSamples+";"
	                        + "\n"
	                        + "f"+id+"_sr"+sampleRate+" ["+nSamples+"] = { "
	                        + s
	                        + "\n"
	                        + "};"
	                        + "\n\n";

  } // end for (var in object)


  openTab(2);

}

-->